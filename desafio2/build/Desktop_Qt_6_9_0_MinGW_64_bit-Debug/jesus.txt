#include "alojamiento.h"
#include "anfitrion.h"
#include <iostream>

Alojamiento::Alojamiento() : anfitrion(nullptr), precioNoche(0.0f),
    cantFechas(0), capFechas(300), fechasOcupadas(new Fecha[30]) {

    amenidades[0] = amenidades[1] = amenidades[2] = false;
    amenidades[3] = amenidades[4] = amenidades[5] = false;
}

Alojamiento::Alojamiento(std::string cod, std::string dep, std::string mun, std::string nom,
                         std::string tipo_, std::string dir, Anfitrion* a, float precio,
                         const bool amen[NUM_AMENIDADES]) :
    codigo(cod), departamento(dep), municipio(mun), nombre(nom), tipo(tipo_),
    direccion(dir), anfitrion(a), precioNoche(precio),
    cantFechas(0), capFechas(300), fechasOcupadas(new Fecha[30]) {

    for (int i = 0; i < NUM_AMENIDADES; ++i)
        amenidades[i] = amen[i];
}

// Getters y setters
std::string Alojamiento::getCodigo() const { return codigo; }
void Alojamiento::setCodigo(const std::string& cod) { codigo = cod; }

std::string Alojamiento::getMunicipio() const { return municipio; }
float Alojamiento::getPrecioNoche() const { return precioNoche; }
void Alojamiento::setPrecioNoche(float precio) { precioNoche = precio; }

Anfitrion* Alojamiento::getAnfitrion() const { return anfitrion; }

// Funciones auxiliares
bool Alojamiento::contieneFecha(const Fecha& f) const {
    for (int i = 0; i < cantFechas; ++i) {
        if (fechasOcupadas[i].toEntero() == f.toEntero())
            return true;
    }
    return false;
}

void Alojamiento::agregarFecha(const Fecha& f) {
    if (contieneFecha(f)) return;

    if (cantFechas >= capFechas) {
        capFechas *= 2;
        Fecha* nuevo = new Fecha[capFechas];
        for (int i = 0; i < cantFechas; ++i)
            nuevo[i] = fechasOcupadas[i];
        delete[] fechasOcupadas;
        fechasOcupadas = nuevo;
    }

    fechasOcupadas[cantFechas++] = f;
}

// Disponibilidad
bool Alojamiento::estaDisponible(const Fecha& entrada, int duracion) const {
    for (int i = 0; i < duracion; ++i)
        if (contieneFecha(entrada.sumarDias(i)))
            return false;
    return true;
}

void Alojamiento::reservarDias(const Fecha& entrada, int duracion) {
    for (int i = 0; i < duracion; ++i)
        agregarFecha(entrada.sumarDias(i));
}

void Alojamiento::liberarDias(const Fecha& inicio, int noches) {
    for (int i = 0; i < noches; ++i) {
        Fecha f = inicio.sumarDias(i);
        for (int j = 0; j < cantFechas; ++j) {
            if (fechasOcupadas[j].toEntero() == f.toEntero()) {
                for (int k = j; k < cantFechas - 1; ++k)
                    fechasOcupadas[k] = fechasOcupadas[k + 1];
                --cantFechas;
                break;
            }
        }
    }
}

// Mostrar información
void Alojamiento::mostrar() const {
    std::cout << "Código: " << codigo << '\n'
              << "Nombre: " << nombre << '\n'
              << "Ubicación: " << departamento << ", " << municipio << '\n'
              << "Tipo: " << tipo << " | Dirección: " << direccion << '\n'
              << "Precio por noche: $" << precioNoche << '\n'
              << "Amenidades: ";

    const std::string nombres[NUM_AMENIDADES] = {
        "ascensor", "piscina", "aire acondicionado",
        "caja fuerte", "parqueadero", "patio"
    };

    bool hayAlguna = false;
    for (int i = 0; i < NUM_AMENIDADES; ++i) {
        if (amenidades[i]) {
            if (hayAlguna) std::cout << ", ";
            std::cout << nombres[i];
            hayAlguna = true;
        }
    }
    if (!hayAlguna) std::cout << "ninguna";
    std::cout << '\n';
}

// Copia y asignación
Alojamiento::Alojamiento(const Alojamiento& otro) :
    codigo(otro.codigo), departamento(otro.departamento), municipio(otro.municipio),
    nombre(otro.nombre), tipo(otro.tipo), direccion(otro.direccion),
    anfitrion(otro.anfitrion), precioNoche(otro.precioNoche),
    capFechas(otro.capFechas), cantFechas(otro.cantFechas),
    fechasOcupadas(new Fecha[otro.capFechas]) {

    for (int i = 0; i < NUM_AMENIDADES; ++i)
        amenidades[i] = otro.amenidades[i];

    for (int i = 0; i < cantFechas; ++i)
        fechasOcupadas[i] = otro.fechasOcupadas[i];
}

Alojamiento& Alojamiento::operator=(const Alojamiento& otro) {
    if (this != &otro) {
        delete[] fechasOcupadas;

        codigo = otro.codigo;
        departamento = otro.departamento;
        municipio = otro.municipio;
        nombre = otro.nombre;
        tipo = otro.tipo;
        direccion = otro.direccion;
        anfitrion = otro.anfitrion;
        precioNoche = otro.precioNoche;

        for (int i = 0; i < NUM_AMENIDADES; ++i)
            amenidades[i] = otro.amenidades[i];

        capFechas = otro.capFechas;
        cantFechas = otro.cantFechas;
        fechasOcupadas = new Fecha[capFechas];
        for (int i = 0; i < cantFechas; ++i)
            fechasOcupadas[i] = otro.fechasOcupadas[i];
    }
    return *this;
}

// Destructor
Alojamiento::~Alojamiento() {
    delete[] fechasOcupadas;
}
#include "anfitrion.h"
#include <iostream>

Anfitrion::Anfitrion()
    : documento(""), nombre(""), clave(""), antiguedad(0), puntuacion(0.0f),
    capacidadAlojamientos(150), cantidadAlojamientos(0) {
    alojamientos = new Alojamiento*[capacidadAlojamientos];
}

Anfitrion::Anfitrion(const std::string& doc, const std::string& nom, int antig, float punt)
    : documento(doc), nombre(nom), clave(""), antiguedad(antig), puntuacion(punt),
    capacidadAlojamientos(300), cantidadAlojamientos(0) {
    alojamientos = new Alojamiento*[capacidadAlojamientos];
}

Anfitrion::Anfitrion(const Anfitrion& otro)
    : documento(otro.documento), nombre(otro.nombre), clave(otro.clave),
    antiguedad(otro.antiguedad), puntuacion(otro.puntuacion),
    capacidadAlojamientos(otro.capacidadAlojamientos),
    cantidadAlojamientos(otro.cantidadAlojamientos) {
    alojamientos = new Alojamiento*[capacidadAlojamientos];
    for (int i = 0; i < cantidadAlojamientos; ++i) {
        alojamientos[i] = otro.alojamientos[i];  // Copia superficial
    }
}

Anfitrion& Anfitrion::operator=(const Anfitrion& otro) {
    if (this != &otro) {
        delete[] alojamientos;

        documento = otro.documento;
        nombre = otro.nombre;
        clave = otro.clave;
        antiguedad = otro.antiguedad;
        puntuacion = otro.puntuacion;
        capacidadAlojamientos = otro.capacidadAlojamientos;
        cantidadAlojamientos = otro.cantidadAlojamientos;

        alojamientos = new Alojamiento*[capacidadAlojamientos];
        for (int i = 0; i < cantidadAlojamientos; ++i) {
            alojamientos[i] = otro.alojamientos[i];
        }
    }
    return *this;
}

Anfitrion::~Anfitrion() {
    delete[] alojamientos;
    alojamientos = nullptr;
}

// Getters
std::string Anfitrion::getDocumento() const { return documento; }
std::string Anfitrion::getNombre() const { return nombre; }
std::string Anfitrion::getClave() const { return clave; }
int Anfitrion::getAntiguedad() const { return antiguedad; }
float Anfitrion::getPuntuacion() const { return puntuacion; }

// Setters
void Anfitrion::setDocumento(const std::string& doc) { documento = doc; }
void Anfitrion::setClave(const std::string& c) { clave = c; }
void Anfitrion::setAntiguedad(int antig) { antiguedad = antig; }
void Anfitrion::setPuntuacion(float punt) { puntuacion = punt; }

// Función para agregar alojamiento
void Anfitrion::agregarAlojamiento(Alojamiento* nuevo) {
    if (cantidadAlojamientos >= capacidadAlojamientos) {
        int nuevaCapacidad = capacidadAlojamientos * 2;
        Alojamiento** nuevoArray = new Alojamiento*[nuevaCapacidad];

        for (int i = 0; i < cantidadAlojamientos; ++i)
            nuevoArray[i] = alojamientos[i];

        delete[] alojamientos;
        alojamientos = nuevoArray;
        capacidadAlojamientos = nuevaCapacidad;
    }

    alojamientos[cantidadAlojamientos++] = nuevo;
}

// Mostrar información del anfitrión
void Anfitrion::mostrar() const {
    std::cout << "\nAnfitrión: " << documento
              << " | Antigüedad: " << antiguedad << " meses"
              << " | Puntuación: " << puntuacion << std::endl;

    std::cout << "Alojamientos asignados: " << cantidadAlojamientos << std::endl;

    for (int i = 0; i < cantidadAlojamientos; ++i) {
        if (alojamientos[i])
            alojamientos[i]->mostrar();
    }
}
#include "base_datos.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstring>

using namespace std;

// ----------------------------
// Funciones auxiliares privadas
// ----------------------------

namespace {
void redimensionarAnfitriones(Anfitrion*& anfitriones, int& capacidad) {
    capacidad *= 2;
    Anfitrion* temp = new Anfitrion[capacidad];
    for (int i = 0; i < capacidad / 2; ++i)
        temp[i] = anfitriones[i];
    delete[] anfitriones;
    anfitriones = temp;
}

void redimensionarHuespedes(Huesped*& huespedes, int& capacidad) {
    capacidad *= 2;
    Huesped* temp = new Huesped[capacidad];
    for (int i = 0; i < capacidad / 2; ++i)
        temp[i] = huespedes[i];
    delete[] huespedes;
    huespedes = temp;
}

void redimensionarAlojamientos(Alojamiento*& alojamientos, int& capacidad) {
    capacidad *= 2;
    Alojamiento* temp = new Alojamiento[capacidad];
    for (int i = 0; i < capacidad / 2; ++i)
        temp[i] = alojamientos[i];
    delete[] alojamientos;
    alojamientos = temp;
}

void redimensionarReservas(Reserva*& reservas, int& capacidad) {
    capacidad *= 2;
    Reserva* temp = new Reserva[capacidad];
    for (int i = 0; i < capacidad / 2; ++i)
        temp[i] = reservas[i];
    delete[] reservas;
    reservas = temp;
}

Anfitrion* buscarAnfitrion(Anfitrion* anfitriones, int cant, const string& documento) {
    for (int i = 0; i < cant; ++i)
        if (anfitriones[i].getDocumento() == documento)
            return &anfitriones[i];
    return nullptr;
}

Huesped* buscarHuesped(Huesped* huespedes, int cant, const string& documento) {
    for (int i = 0; i < cant; ++i)
        if (huespedes[i].getDocumento() == documento)
            return &huespedes[i];
    return nullptr;
}

Alojamiento* buscarAlojamiento(Alojamiento* alojamientos, int cant, const string& codigo) {
    for (int i = 0; i < cant; ++i)
        if (alojamientos[i].getCodigo() == codigo)
            return &alojamientos[i];
    return nullptr;
}
}

// ----------------------------
// 1. Cargar todos los datos
// ----------------------------
void cargarBaseDatos(Anfitrion*& anfitriones, int& cantAnfitriones,
                     Alojamiento*& alojamientos, int& cantAlojamientos,
                     Huesped*& huespedes, int& cantHuespedes,
                     Reserva*& reservas, int& cantReservas, int& capacidad)
{
    string linea;

    // =============================
    // Cargar ANFITRIONES
    // =============================
    ifstream archAnfit("anfitriones.txt");
    if (!archAnfit) {
        cerr << "Error abriendo anfitriones.txt\n";
        return;
    }

    getline(archAnfit, linea); // Saltar encabezado
    int capAnfit = 10;
    anfitriones = new Anfitrion[capAnfit];
    cantAnfitriones = 0;

    while (getline(archAnfit, linea)) {
        stringstream ss(linea);
        string doc, nombre, clave, antigStr, puntStr;

        getline(ss, doc, ';');
        getline(ss, nombre, ';');
        getline(ss, antigStr, ';');
        getline(ss, puntStr, ';');
        getline(ss, clave, ';');

        Anfitrion nuevo(doc, nombre, stoi(antigStr), stof(puntStr));
        nuevo.setClave(clave);

        if (cantAnfitriones >= capAnfit)
            redimensionarAnfitriones(anfitriones, capAnfit);

        anfitriones[cantAnfitriones++] = nuevo;
    }
    archAnfit.close();

    // =============================
    // Cargar ALOJAMIENTOS
    // =============================
    ifstream archAloj("alojamientos.txt");
    if (!archAloj) {
        cerr << "Error abriendo alojamientos.txt\n";
        return;
    }

    getline(archAloj, linea); // Saltar encabezado
    int capAloj = 10;
    alojamientos = new Alojamiento[capAloj];
    cantAlojamientos = 0;

    while (getline(archAloj, linea)) {
        stringstream ss(linea);
        string cod, nom, docAnfit, dep, mun, tipo, dir, precioStr, amenStr;

        getline(ss, cod, ';'); getline(ss, nom, ';'); getline(ss, docAnfit, ';');
        getline(ss, dep, ';'); getline(ss, mun, ';'); getline(ss, tipo, ';');
        getline(ss, dir, ';'); getline(ss, precioStr, ';'); getline(ss, amenStr, ';');

        float precio = stof(precioStr);
        bool amen[6] = {0};
        string bit; int i = 0;
        stringstream ssAmen(amenStr);
        while (getline(ssAmen, bit, ',') && i < 6)
            amen[i++] = (bit == "1");

        Anfitrion* anfitrion = buscarAnfitrion(anfitriones, cantAnfitriones, docAnfit);
        if (!anfitrion) {
            cerr << "Anfitrión no encontrado para alojamiento " << cod << endl;
            continue;
        }

        if (cantAlojamientos >= capAloj)
            redimensionarAlojamientos(alojamientos, capAloj);

        alojamientos[cantAlojamientos] = Alojamiento(cod, dep, mun, nom, tipo, dir, anfitrion, precio, amen);
        anfitrion->agregarAlojamiento(&alojamientos[cantAlojamientos]);
        cantAlojamientos++;
    }
    archAloj.close();

    // =============================
    // Cargar HUESPEDES
    // =============================
    ifstream archHuesp("huespedes.txt");
    if (!archHuesp) {
        cerr << "Error abriendo huespedes.txt\n";
        return;
    }

    getline(archHuesp, linea); // Saltar encabezado
    int capHuesp = 10;
    huespedes = new Huesped[capHuesp];
    cantHuespedes = 0;

    while (getline(archHuesp, linea)) {
        stringstream ss(linea);
        string doc, nombre, clave, antigStr, puntStr;

        getline(ss, doc, ';'); getline(ss, nombre, ';');
        getline(ss, antigStr, ';'); getline(ss, puntStr, ';'); getline(ss, clave, ';');

        Huesped nuevo(doc, nombre, stoi(antigStr), stof(puntStr));
        nuevo.setClave(clave);

        if (cantHuespedes >= capHuesp)
            redimensionarHuespedes(huespedes, capHuesp);

        huespedes[cantHuespedes++] = nuevo;
    }
    archHuesp.close();

    // =============================
    // Cargar RESERVAS
    // =============================
    ifstream archRes("reservas.txt");
    if (!archRes) {
        cerr << "Error abriendo reservas.txt\n";
        return;
    }

    getline(archRes, linea); // Saltar encabezado
    int capRes = 10;
    reservas = new Reserva[capRes];
    cantReservas = 0;
    capacidad = capRes;

    while (getline(archRes, linea)) {
        stringstream ss(linea);
        string cod, codAloj, docHuesp, fechaIn, durStr, metodo, fechaPag, montoStr, nota;

        if (!getline(ss, cod, ';') || !getline(ss, codAloj, ';') || !getline(ss, docHuesp, ';') ||
            !getline(ss, fechaIn, ';') || !getline(ss, durStr, ';') || !getline(ss, metodo, ';') ||
            !getline(ss, fechaPag, ';') || !getline(ss, montoStr, ';') || !getline(ss, nota, ';')) {
            cerr << "Línea de reserva malformada: " << linea << "\n";
            continue;
        }

        // Parsear fechas
        int d, m, a;
        Fecha entrada, pago;
        if (sscanf(fechaIn.c_str(), "%d/%d/%d", &d, &m, &a) != 3) {
            cerr << "Fecha entrada inválida en reserva " << cod << "\n"; continue;
        }
        entrada = Fecha(d, m, a);

        if (sscanf(fechaPag.c_str(), "%d/%d/%d", &d, &m, &a) != 3) {
            cerr << "Fecha pago inválida en reserva " << cod << "\n"; continue;
        }
        pago = Fecha(d, m, a);

        // Buscar relaciones
        Huesped* h = buscarHuesped(huespedes, cantHuespedes, docHuesp);
        Alojamiento* aObj = buscarAlojamiento(alojamientos, cantAlojamientos, codAloj);
        if (!h || !aObj) {
            cerr << "Reserva " << cod << " inválida (huesped o alojamiento no encontrado)\n";
            continue;
        }

        int duracion = stoi(durStr);
        if (h->hayConflicto(entrada, duracion)) {
            cerr << "Reserva " << cod << " no agregada por conflicto de fechas.\n";
            continue;
        }

        if (cantReservas >= capRes) {
            redimensionarReservas(reservas, capRes);
            capacidad = capRes;
        }

        int monto = stoi(montoStr);
        reservas[cantReservas] = Reserva(cod, aObj, h, entrada, duracion, metodo, pago, monto, nota);
        h->agregarReserva(&reservas[cantReservas]);
        aObj->reservarDias(entrada, duracion);
        cantReservas++;
    }

    archRes.close();
}


// ----------------------------
// 2. Buscar alojamientos disponibles
// ----------------------------
void buscarAlojamientosDisponibles(Alojamiento* alojamientos, int cantA,
                                   const Fecha& entrada, int duracion,
                                   const string& municipio,
                                   float precioMax, float puntMin)
{
    cout << "\n=== ALOJAMIENTOS DISPONIBLES ===\n";
    bool encontrados = false;

    for (int i = 0; i < cantA; ++i) {
        Alojamiento& a = alojamientos[i];

        if (a.getMunicipio() != municipio) continue;
        if (!a.estaDisponible(entrada, duracion)) continue;
        if (precioMax != -1 && a.getPrecioNoche() > precioMax) continue;
        if (puntMin != -1 && a.getAnfitrion()->getPuntuacion() < puntMin) continue;

        a.mostrar();
        cout << "-------------------------\n";
        encontrados = true;
    }

    if (!encontrados)
        cout << "No se encontraron alojamientos disponibles.\n";
}
#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <ctime>
using namespace std;

#include "base_datos.h"
#include "anfitrion.h"
#include "huesped.h"
#include "reserva.h"
#include "alojamiento.h"
#include "fecha.h"
#include "controlador.h"

int siguienteNumeroReserva = 1;


Controlador::Controlador() {
    anfitriones = nullptr;
    alojamientos = nullptr;
    huespedes = nullptr;
    reservas = new Reserva[5];

    cantAnfitriones = cantAlojamientos = 0;
    cantHuespedes = cantReservas = 0;
    capReservas = 5;

    siguienteNumeroReserva = obtenerSiguienteNumeroReserva();
    std::cout<<"hola";

    cargarBaseDatos(anfitriones, cantAnfitriones,
                    alojamientos, cantAlojamientos,
                    huespedes, cantHuespedes,
                    reservas, cantReservas, capReservas);
    std::cout<<"hola20";
}

void Controlador::iniciar(){
    menuPrincipal();
}

void Controlador::menuPrincipal() {
    int opcion;
    do {
        cout << "\n===== MENÚ PRINCIPAL =====\n";
        cout << "1. Iniciar sesión\n";
        cout << "0. Salir\n";
        cout << "Opción: ";
        cin >> opcion;

        switch (opcion) {
        case 1:
            iniciarSesion();
            break;
        case 0:
            cout << "Gracias por usar el sistema. ¡Hasta luego!\n";
            break;
        default:
            cout << "Opción inválida.\n";
        }

    } while (opcion != 0);
}

void Controlador::iniciarSesion(){
    string doc, claveIngresada;
    cout << "\n--- Iniciar sesión ---\n";
    cout << "Ingrese su número de documento: ";
    cin >> doc;
    cout << "Ingrese su clave: ";
    cin >> claveIngresada;

    for (int i = 0; i < cantHuespedes; ++i) {
        if (huespedes[i].getDocumento() == doc && huespedes[i].getClave() == claveIngresada) {
            mostrarMenuHuesped(&huespedes[i]);
            return;
        }
    }

    for (int i = 0; i < cantAnfitriones; ++i) {
        if (anfitriones[i].getDocumento() == doc && anfitriones[i].getClave() == claveIngresada) {
            mostrarMenuAnfitrion(&anfitriones[i]);
            return;
        }
    }

    cout << "Documento o clave incorrectos.\n";
}

void Controlador::mostrarMenuHuesped(Huesped* h){
    int opcion;
    do {
        cout << "\n=== MENÚ HUÉSPED ===\n";
        cout << "Bienvenido, " << h->getNombre() << " (documento: " << h->getDocumento() << ")\n";
        cout << "1. Buscar alojamientos disponibles\n";
        cout << "2. Reservar alojamiento\n";
        cout << "3. Mostrar mis reservaciones\n";
        cout << "4. Ver antigüedad y puntuación\n";
        cout << "5. Anular una reservación\n";
        cout << "0. Cerrar sesión\n";
        cout << "Opción: ";
        cin >> opcion;

        switch (opcion) {
        case 1:
            buscarYReservarAlojamiento(h);
            break;
        case 2:
            reservarAlojamiento(h);
            break;
        case 3:
            h->mostrar();
            break;
        case 4:
            cout << "Antigüedad: " << h->getAntiguedad() << " meses\n";
            cout << "Puntuación: " << h->getPuntuacion() << "/5.0\n";
            break;
        case 5: {
            cout << "\n--- Reservaciones activas ---\n";
            int seleccionables[100], totalMostrar = 0;

            for (int i = 0; i < cantReservas; ++i) {
                if (reservas[i].getHuesped()->getDocumento() == h->getDocumento()) {
                    cout << (totalMostrar + 1) << ". ";
                    reservas[i].mostrarComprobante();
                    seleccionables[totalMostrar++] = i;
                }
            }

            if (totalMostrar == 0) {
                cout << "No tiene reservaciones activas.\n";
                break;
            }

            int eleccion;
            cout << "Seleccione el número de la reserva a anular (0 para cancelar): ";
            cin >> eleccion;
            if (eleccion < 1 || eleccion > totalMostrar) break;

            int idx = seleccionables[eleccion - 1];
            Reserva* r = &reservas[idx];              // Apunta antes de modificar nada
            string codigo = r->getCodigo();           // Guarda el código
            anularReservacion(codigo, h, nullptr);    // Anula por código, ya no usas índices viejos
            break;
        }
        case 0:
            cout << "Sesión finalizada.\n";
            break;
        default:
            cout << "Opción inválida.\n";
        }
    } while (opcion != 0);
}

void Controlador::mostrarMenuAnfitrion(Anfitrion* a){
    int opcion;
    do {
        cout << "\n=== MENÚ ANFITRIÓN ===\n";
        cout << "Bienvenido, " << a->getNombre() << " (documento: " << a->getDocumento() << ")\n";
        cout << "1. Mostrar mis alojamientos\n";
        cout << "2. Ver antigüedad y puntuación\n";
        cout << "3. Anular una reservación asociada a mis alojamientos\n";
        cout << "4. Consultar reservaciones en rango de fechas\n";
        cout << "5. Actualizar histórico de reservas\n";
        cout << "6. Mostrar histórico de reservas\n";
        cout << "0. Cerrar sesión\n";
        cout << "Opción: ";
        cin >> opcion;

        switch (opcion) {
        case 1:
            a->mostrar();
            break;
        case 2:
            cout << "\nAntigüedad: " << a->getAntiguedad() << " meses\n";
            cout << "Puntuación: " << a->getPuntuacion() << "/5.0\n";
            break;
        case 3: {
            string cod;
            cout << "Código de la reservación a anular: ";
            cin >> cod;
            anularReservacion(cod, nullptr, a);
            break;
        }
        case 4: {
            int d1, m1, a1, d2, m2, a2;
            cout << "Ingrese fecha inicial (D M A): ";
            cin >> d1 >> m1 >> a1;
            cout << "Ingrese fecha final (D M A): ";
            cin >> d2 >> m2 >> a2;
            Fecha ini(d1, m1, a1), fin(d2, m2, a2);

            int total = 0;
            for (int i = 0; i < cantReservas; ++i) {
                Reserva& r = reservas[i];
                if (r.getAlojamiento()->getAnfitrion() == a &&
                    r.getFechaEntrada().esMayorQue(ini) &&
                    r.getFechaEntrada().esMenorQue(fin)) {
                    cout << "\n[" << ++total << "] ";
                    r.mostrarComprobante();
                }
            }

            if (total == 0)
                cout << "No se encontraron reservaciones en ese rango.\n";

            break;
        }
        case 5: {
            int d, m, a;
            cout << "--- Actualizar histórico ---\n";
            cout << "Ingrese fecha de corte (D M A): ";
            cin >> d >> m >> a;
            Fecha fechaCorte(d, m, a);

            // Ejecutar depuración
            depurarReservas(fechaCorte);

            // Actualizar archivo reservas.txt después de depurar
            sobrescribirArchivoReservas();

            cout << "Histórico actualizado. Solo se conservaron reservas desde la fecha indicada.\n";
            break;
        }
        case 6:
            this->mostrarHistorico();
            break;
        case 0:
            cout << "Sesión finalizada.\n";
            break;
        default:
            cout << "Opción inválida.\n";
        }
    } while (opcion != 0);
}

void Controlador::asegurarCapacidadReservas() {
    if (cantReservas >= capReservas) {
        capReservas *= 2;
        Reserva* nuevo = new Reserva[capReservas];
        for (int i = 0; i < cantReservas; ++i)
            nuevo[i] = reservas[i];
        delete[] reservas;
        reservas = nuevo;

        // Reparar punteros en los huéspedes
        for (int i = 0; i < cantHuespedes; ++i)
            huespedes[i].repararPunterosReservas(reservas, cantReservas);
    }
}

void Controlador::buscarYReservarAlojamiento(Huesped* h)
{
    cout << "--- Buscar y reservar alojamiento ---\n";
    string municipio;
    int d, m, a, noches;

    cout << "Municipio: ";
    cin >> ws;
    getline(cin, municipio);

    cout << "Fecha de entrada (D M A): ";
    cin >> d >> m >> a;
    cout << "Duración (noches): ";
    cin >> noches;
    Fecha entrada(d, m, a);

    Fecha hoy = getFechaSistema();
    Fecha maxPermitida = hoy.sumarDias(365);

    if (entrada.esMenorQue(hoy) || entrada.esMayorQue(maxPermitida)) {
        cout << "La fecha de entrada debe estar entre hoy y dentro de 12 meses máximo.\n";
        return;
    }

    // Filtros opcionales
    char aplicarFiltro;
    float precioMax = -1, puntMin = -1;
    cout << "¿Desea aplicar filtros de precio y puntuación? (s/n): ";
    cin >> aplicarFiltro;
    if (aplicarFiltro=='s' || aplicarFiltro=='S') {
        cout << "Ingrese precio máximo por noche (-1 si no desea aplicar): ";
        cin >> precioMax;
        cout << "Ingrese puntuación mínima del anfitrión (-1 si no desea aplicar): ";
        cin >> puntMin;
    }

    // Recolectar disponibles
    const int MAX_DISPONIBLES = 100;
    Alojamiento* disponibles[MAX_DISPONIBLES];
    int cantDisponibles = 0;
    for (int i = 0; i < cantAlojamientos; ++i) {
        Alojamiento& a = alojamientos[i];

        if (a.getMunicipio() == municipio &&
            a.estaDisponible(entrada, noches) &&
            (precioMax < 0 || a.getPrecioNoche() <= precioMax) &&
            (puntMin < 0 || a.getAnfitrion()->getPuntuacion() >= puntMin))
        {
            if (cantDisponibles < MAX_DISPONIBLES)
                disponibles[cantDisponibles++] = &a;
        }
    }

    if (cantDisponibles == 0) {
        cout << "No hay alojamientos disponibles.\n";
        return;
    }

    // Mostrar lista y elegir
    cout << "\n=== ALOJAMIENTOS DISPONIBLES ===\n";
    for (int i = 0; i < cantDisponibles; ++i) {
        cout << i + 1 << ".\n";
        disponibles[i]->mostrar();
        cout << "Puntuación del anfitrión: "
             << disponibles[i]->getAnfitrion()->getPuntuacion()
             << " / 5.0\n---------------------\n";
    }

    int opcion;
    cout << "Seleccione número (0 cancelar): ";
    cin >> opcion;
    if (opcion < 1 || opcion > cantDisponibles) {
        cout << "Reserva cancelada.\n";
        return;
    }

    Alojamiento* aloj = disponibles[opcion - 1];

    // Pedir pago
    string metodo;
    cout << "Metodo de pago" << "\n";
    cout << "1. PSE" << "\n";
    cout << "2. TCredito" << "\n";
    cout << "Opción: ";
    cin >> ws;
    getline(cin, metodo);
    if (metodo != "1" && metodo != "2"){
        cout << "Opción inválida. Reserva cancelada.\n";
        return;
    }
    if (metodo == "1"){
        metodo = "PSE";
    } else{
        metodo = "TCredito";
    }

    // Pedir anotación
    string nota;
    cout << "Ingrese anotación (max 1000 chars): ";
    cin >> ws;
    getline(cin, nota);

    // ... justo antes de crear la Reserva
    extern int siguienteNumeroReserva; // si está fuera del main()
    std::ostringstream oss;
    oss << "RSV" << std::setw(3) << std::setfill('0') << siguienteNumeroReserva++;
    string codigo = oss.str();
    Fecha fechaPago = entrada;
    float monto = noches * aloj->getPrecioNoche();

    // Verificar conflicto antes de crear la reserva
    if (h->hayConflicto(entrada, noches)) {
        cout << "Conflicto de fechas. No se realizó la reserva.\n";
        return;
    }

    // Redimensionar arreglo si hace falta
    void asegurarCapacidadReservas();

    // Crear y guardar la reserva
    reservas[cantReservas] = Reserva(codigo, aloj, h, entrada, noches, metodo, fechaPago, monto, nota);
    Reserva* ptrReserva = &reservas[cantReservas];
    ++cantReservas;

    h->agregarReserva(ptrReserva);
    aloj->reservarDias(entrada, noches);
    this->guardarReservaIndividual(*ptrReserva);

    // Mostrar comprobante usando método encapsulado
    ptrReserva->mostrarComprobante();
}

void Controlador::reservarAlojamiento(Huesped* h)
{
    cout << "--- Reservar alojamiento ---\n";
    string cod;
    int d, m, a, dur;
    cout << "Código del alojamiento: ";
    cin >> cod;
    cout << "Fecha entrada (D M A): ";
    cin >> d >> m >> a;
    cout << "Duración (noches): ";
    cin >> dur;
    Fecha entrada(d, m, a);

    Fecha hoy = getFechaSistema();
    Fecha maxPermitida = hoy.sumarDias(365);

    if (entrada.esMenorQue(hoy) || entrada.esMayorQue(maxPermitida)) {
        cout << "La fecha de entrada debe estar entre hoy y dentro de 12 meses máximo.\n";
        return;
    }

    Alojamiento* aloj = nullptr;
    for (int i = 0; i < cantAlojamientos; ++i) {
        if (alojamientos[i].getCodigo() == cod) {
            aloj = &alojamientos[i];
            break;
        }
    }

    if (!aloj) {
        cout << "Alojamiento no encontrado.\n";
        return;
    }

    if (!aloj->estaDisponible(entrada, dur)) {
        cout << "El alojamiento no está disponible.\n";
        return;
    }

    // Pedir pago
    string metodo;
    cout << "Metodo de pago" << "\n";
    cout << "1. PSE" << "\n";
    cout << "2. TCredito" << "\n";
    cout << "Opción: ";
    cin >> ws;
    getline(cin, metodo);
    if (metodo != "1" && metodo != "2"){
        cout << "Opción inválida. Reserva cancelada.\n";
        return;
    }
    if (metodo == "1"){
        metodo = "PSE";
    } else{
        metodo = "TCredito";
    }

    // Pedir anotación
    string nota;
    cout << "Ingrese anotación (max 1000 chars): ";
    cin >> ws;
    getline(cin, nota);
    /*
    // Generar los datos de la reserva
    string codigo = "RSV" + to_string(cantReservas + 1);
    Fecha fechaPago = entrada; // Simulación de pago en fecha de entrada
    float monto = dur * aloj->getPrecio();
    */
    // ... justo antes de crear la Reserva
    std::ostringstream oss;
    oss << "RSV" << std::setw(3) << std::setfill('0') << siguienteNumeroReserva++;
    string codigo = oss.str();
    Fecha fechaPago = entrada;
    float monto = dur * aloj->getPrecioNoche();

    // 1) Creamos la reserva en HEAP para construirla:
    Reserva* nueva = new Reserva(codigo, aloj, h, entrada, dur, metodo, fechaPago, monto, nota);

    // 2) Comprobamos conflictos en el huesped con NUEVA:
    if (h->hayConflicto(entrada, dur)) {
        cout << "El huésped ya tiene una reserva en esas fechas.\n";
        delete nueva;
        return;
    }

    // 3) Aseguramos capacidad y copiamos en tu array principal:
    void asegurarCapacidadReservas();
    reservas[cantReservas] = *nueva;   // copia "por valor" dentro de tu buffer

    // 4) INSERTAMOS sólo una vez EN EL HUESPED:
    h->agregarReserva(&reservas[cantReservas]);

    // 5) Marcamos los días en el alojamiento:
    aloj->reservarDias(entrada, dur);

    // 6) Avanzamos el contador:
    cantReservas++;

    // 7) Guardamos en disco:
    this->guardarReservaIndividual(reservas[cantReservas - 1]);

    // 8) Limpieza del temporal:
    delete nueva;

    // Mostrar comprobante usando método encapsulado
    reservas[cantReservas - 1].mostrarComprobante();
}

int Controlador::obtenerSiguienteNumeroReserva(){
    ifstream archivo("reservas.txt");
    if (!archivo.is_open()) return 1;

    string linea, ultimoCodigo;
    while (getline(archivo, linea)) {
        if (linea.empty()) continue;
        size_t pos = linea.find(';');
        if (pos != string::npos)
            ultimoCodigo = linea.substr(0, pos);
    }
    archivo.close();

    if (ultimoCodigo.size() < 4) return 1;
    int numero = stoi(ultimoCodigo.substr(3));
    return numero + 1;
}

void Controlador::anularReservacion(const string& codigo, Huesped* h, Anfitrion* a) {
    for (int i = 0; i < cantReservas; ++i) {
        if (reservas[i].getCodigo() == codigo) {
            bool autorizado = false;
            Huesped* h_afectado = nullptr;

            if (h && reservas[i].getHuesped()->getDocumento() == h->getDocumento()) {
                autorizado = true;
                h_afectado = h;
            } else if (a && reservas[i].getAlojamiento()->getAnfitrion()->getDocumento() == a->getDocumento()) {
                autorizado = true;
                h_afectado = reservas[i].getHuesped();
            }

            if (!autorizado) {
                cout << "No tiene permiso para anular esta reservación.\n";
                return;
            }

            // Eliminar del huésped
            if (h_afectado)
                //h_afectado->eliminarReservaPorCodigo(codigo);

            // Compactar arreglo global de reservas
            for (int j = i; j < cantReservas - 1; ++j)
                reservas[j] = reservas[j + 1];
            cantReservas--;

            // Reparar punteros internos del huésped (opcional si ya se eliminó la reserva)
            if (h_afectado && cantReservas > 0)
                h_afectado->repararPunterosReservas(reservas, cantReservas);

            sobrescribirArchivoReservas();
            cout << "Reservación anulada con éxito.\n";
            return;
        }
    }

    cout << "Reservación no encontrada.\n";
}

void Controlador::mostrarHistorico() {
    std::ifstream archivo("historico_reservas.txt");
    if (!archivo.is_open()) {
        std::cout << "No se pudo abrir el archivo histórico.\n";
        return;
    }

    std::string linea;
    int contador = 1;
    std::cout << "\n--- Histórico de reservaciones ---\n";
    while (getline(archivo, linea)) {
        if (linea.empty()) continue;
        std::cout << contador++ << ". " << linea << "\n";
    }

    archivo.close();
    if (contador == 1) std::cout << "No hay reservas históricas registradas.\n";
}

void Controlador::guardarReservaIndividual(const Reserva& r) {
    std::ofstream archivo("reservas.txt", std::ios::app);
    if (!archivo.is_open()) {
        std::cout << "Error al guardar la reserva en archivo.\n";
        return;
    }

    archivo << r.getCodigo() << ";"
            << r.getAlojamiento()->getCodigo() << ";"
            << r.getHuesped()->getDocumento() << ";"
            << r.getFechaEntrada().getDia() << "/"
            << r.getFechaEntrada().getMes() << "/"
            << r.getFechaEntrada().getAnio() << ";"
            << r.getDuracion() << ";"
            << r.getMetodoPago() << ";"
            << r.getFechaPago().getDia() << "/"
            << r.getFechaPago().getMes() << "/"
            << r.getFechaPago().getAnio() << ";"
            << r.getMonto() << ";"
            << r.getAnotacion() << "\n";

    archivo.close();
}

void Controlador::sobrescribirArchivoReservas() {
    std::ofstream archivo("reservas.txt");
    if (!archivo.is_open()) {
        std::cout << "Error al escribir en reservas.txt\n";
        return;
    }

    archivo << "codigoReserva;codAlojamiento;docHuesped;fechaEntrada;duracion;metodoPago;fechaPago;monto;anotacion\n";

    for (int i = 0; i < cantReservas; ++i) {
        const Reserva& r = reservas[i];
        archivo << r.getCodigo() << ";"
                << r.getAlojamiento()->getCodigo() << ";"
                << r.getHuesped()->getDocumento() << ";"
                << r.getFechaEntrada().getDia() << "/"
                << r.getFechaEntrada().getMes() << "/"
                << r.getFechaEntrada().getAnio() << ";"
                << r.getDuracion() << ";"
                << r.getMetodoPago() << ";"
                << r.getFechaPago().getDia() << "/"
                << r.getFechaPago().getMes() << "/"
                << r.getFechaPago().getAnio() << ";"
                << r.getMonto() << ";"
                << r.getAnotacion() << "\n";
    }

    archivo.close();
}

void Controlador::depurarReservas(const Fecha& fechaCorte) {
    std::ofstream archivo("historico_reservas.txt", std::ios::app);
    if (!archivo.is_open()) {
        std::cout << "No se pudo abrir el archivo histórico.\n";
        return;
    }

    int nuevaCantidad = 0;
    for (int i = 0; i < cantReservas; ++i) {
        if (reservas[i].getFechaEntrada().esMayorQue(fechaCorte) ||
            reservas[i].getFechaEntrada().toEntero() == fechaCorte.toEntero()) {
            reservas[nuevaCantidad++] = reservas[i];
        } else {
            archivo << reservas[i].getCodigo() << ";"
                    << reservas[i].getAlojamiento()->getCodigo() << ";"
                    << reservas[i].getHuesped()->getDocumento() << ";"
                    << reservas[i].getFechaEntrada().getDia() << "/"
                    << reservas[i].getFechaEntrada().getMes() << "/"
                    << reservas[i].getFechaEntrada().getAnio() << ";"
                    << reservas[i].getDuracion() << ";"
                    << reservas[i].getMetodoPago() << ";"
                    << reservas[i].getFechaPago().getDia() << "/"
                    << reservas[i].getFechaPago().getMes() << "/"
                    << reservas[i].getFechaPago().getAnio() << ";"
                    << reservas[i].getMonto() << ";"
                    << reservas[i].getAnotacion() << "\n";
        }
    }

    cantReservas = nuevaCantidad;
    archivo.close();
}


Controlador::~Controlador() {
    delete[] reservas;
    delete[] huespedes;
    delete[] alojamientos;
    delete[] anfitriones;
}

#include "fecha.h"
#include <iostream>
#include <ctime>
#include <iomanip>

// Constructor por defecto
Fecha::Fecha() : dia(1), mes(1), anio(2000) {}

// Constructor con parámetros
Fecha::Fecha(int d, int m, int a) : dia(d), mes(m), anio(a) {}

// Getters
int Fecha::getDia() const { return dia; }
int Fecha::getMes() const { return mes; }
int Fecha::getAnio() const { return anio; }

// Setters
void Fecha::setDia(int d) { dia = d; }
void Fecha::setMes(int m) { mes = m; }
void Fecha::setAnio(int a) { anio = a; }

// Mostrar fecha en formato dd/mm/aaaa
void Fecha::mostrar() const {
    std::cout << std::setfill('0') << std::setw(2) << dia << "/"
              << std::setw(2) << mes << "/"
              << anio << std::endl;
}

// Convertir a formato AAAAMMDD como entero
int Fecha::toEntero() const {
    return anio * 10000 + mes * 100 + dia;
}

// Determinar si es bisiesto
bool Fecha::esBisiesto() const {
    return (anio % 4 == 0 && anio % 100 != 0) || (anio % 400 == 0);
}

// Convertir a día del año (0-365)
int Fecha::aDiaDelAnio() const {
    static const int diasPorMes[12] = {31, 28, 31, 30, 31, 30,
                                       31, 31, 30, 31, 30, 31};
    int suma = 0;
    for (int i = 0; i < mes - 1; ++i) {
        suma += diasPorMes[i];
        if (i == 1 && esBisiesto()) suma++; // febrero bisiesto
    }
    return suma + dia - 1;
}

// Comparación
bool Fecha::esMayorQue(const Fecha& otra) const {
    return toEntero() > otra.toEntero();
}

bool Fecha::esMenorQue(const Fecha& otra) const {
    return toEntero() < otra.toEntero();
}

// Obtener nombre del día de la semana (usando algoritmo de Zeller modificado)
std::string Fecha::obtenerDiaSemana() const {
    static const std::string dias[] = {"Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"};
    static const int ajustes[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};

    int y = anio;
    if (mes < 3) y -= 1;

    int diaSemana = (y + y / 4 - y / 100 + y / 400 + ajustes[mes - 1] + dia) % 7;
    return dias[diaSemana];
}

// Mostrar fecha en formato extendido
void Fecha::mostrarExtendido() const {
    static const std::string meses[] = {
        "enero", "febrero", "marzo", "abril", "mayo", "junio",
        "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"
    };

    std::cout << obtenerDiaSemana() << ", "
              << dia << " de " << meses[mes - 1]
              << " del " << anio << std::endl;
}

// Retorna una nueva fecha sumando días (usa mktime)
Fecha Fecha::sumarDias(int dias) const {
    std::tm t = {};
    t.tm_mday = dia + dias;
    t.tm_mon = mes - 1;
    t.tm_year = anio - 1900;

    std::mktime(&t); // normaliza la fecha

    return Fecha(t.tm_mday, t.tm_mon + 1, t.tm_year + 1900);
}

// Obtener fecha actual del sistema
Fecha getFechaSistema() {
    std::time_t t = std::time(nullptr);
    std::tm* now = std::localtime(&t);
    return Fecha(now->tm_mday, now->tm_mon + 1, now->tm_year + 1900);
}
#include "huesped.h"
#include "fecha.h"
#include "reserva.h"
#include <iostream>
using namespace std;

Huesped::Huesped() : documento(""), nombre(""), clave(""),
    antiguedad(0), puntuacion(0.0),
    capacidadReservas(1000), cantidadReservas(0) {
    reservas = new Reserva*[capacidadReservas];
}

Huesped::Huesped(string doc, string nom, int antig, float punt)
    : documento(doc), nombre(nom), clave(""),
    antiguedad(antig), puntuacion(punt),
    capacidadReservas(1000), cantidadReservas(0) {
    reservas = new Reserva*[capacidadReservas];
}

Huesped::Huesped(const Huesped& otro)
    : documento(otro.documento), nombre(otro.nombre),
    antiguedad(otro.antiguedad), puntuacion(otro.puntuacion),
    clave(otro.clave), capacidadReservas(otro.capacidadReservas),
    cantidadReservas(otro.cantidadReservas) {
    reservas = new Reserva*[capacidadReservas];
    for (int i = 0; i < cantidadReservas; ++i)
        reservas[i] = otro.reservas[i];
}

Huesped& Huesped::operator=(const Huesped& otro) {
    if (this != &otro) {
        delete[] reservas;

        documento = otro.documento;
        nombre = otro.nombre;
        antiguedad = otro.antiguedad;
        puntuacion = otro.puntuacion;
        clave = otro.clave;
        capacidadReservas = otro.capacidadReservas;
        cantidadReservas = otro.cantidadReservas;

        reservas = new Reserva*[capacidadReservas];
        for (int i = 0; i < cantidadReservas; ++i)
            reservas[i] = otro.reservas[i];
    }
    return *this;
}

// ----------- Getters & Setters -----------
string Huesped::getDocumento() const { return documento; }
string Huesped::getNombre() const { return nombre; }
int Huesped::getAntiguedad() const { return antiguedad; }
float Huesped::getPuntuacion() const { return puntuacion; }
string Huesped::getClave() const { return clave; }

void Huesped::setDocumento(const string& doc) { documento = doc; }
void Huesped::setAntiguedad(int antig) { antiguedad = antig; }
void Huesped::setPuntuacion(float punt) { puntuacion = punt; }
void Huesped::setClave(const string& c) { clave = c; }

// ----------- Reservas -----------
bool Huesped::agregarReserva(Reserva* nueva) {
    if (hayConflicto(nueva->getFechaEntrada(), nueva->getDuracion()))
        return false;

    if (cantidadReservas >= capacidadReservas)
        redimensionarReservas();

    reservas[cantidadReservas++] = nueva;
    return true;
}

bool Huesped::hayConflicto(const Fecha& entrada, int duracion) const {
    int y1 = entrada.getAnio();
    int start1 = entrada.aDiaDelAnio();
    int end1 = start1 + duracion;

    for (int i = 0; i < cantidadReservas; ++i) {
        Reserva* r = reservas[i];
        Fecha fe = r->getFechaEntrada();

        if (fe.getAnio() != y1) continue;

        int start2 = fe.aDiaDelAnio();
        int end2 = start2 + r->getDuracion();

        if (!(end1 <= start2 || end2 <= start1))
            return true;
    }
    return false;
}

void Huesped::eliminarReserva(Reserva* r) {
    for (int i = 0; i < cantidadReservas; ++i) {
        if (reservas[i] == r) {
            for (int j = i; j < cantidadReservas - 1; ++j)
                reservas[j] = reservas[j + 1];
            reservas[--cantidadReservas] = nullptr;
            return;
        }
    }
}

void Huesped::eliminarReservaPorCodigo(const string& codigo) {
    for (int i = 0; i < cantidadReservas; ++i) {
        if (reservas[i] && reservas[i]->getCodigo() == codigo) {
            // Evitar uso de puntero inválido
            for (int j = i; j < cantidadReservas - 1; ++j)
                reservas[j] = reservas[j + 1];
            reservas[--cantidadReservas] = nullptr;
            return;
        }
    }
}

void Huesped::mostrar() const {
    cout << "Huésped: " << documento
         << " | Antigüedad: " << antiguedad
         << " meses | Puntuación: " << puntuacion << endl;

    if (cantidadReservas == 0) {
        cout << "No tiene reservaciones activas.\n";
        return;
    }

    for (int i = 0; i < cantidadReservas; ++i) {
        cout << i + 1 << ". ";
        reservas[i]->mostrarComprobante();
    }
}

// ----------- Utilidades -----------
void Huesped::redimensionarReservas() {
    capacidadReservas *= 2;
    Reserva** temp = new Reserva*[capacidadReservas];
    for (int i = 0; i < cantidadReservas; ++i)
        temp[i] = reservas[i];
    delete[] reservas;
    reservas = temp;
}

void Huesped::repararPunterosReservas(Reserva* nuevoArreglo, int cantReservas) {
    for (int i = 0; i < cantReservas; ++i) {
        Reserva* actual = &nuevoArreglo[i];
        for (int j = 0; j < cantidadReservas; ++j) {
            if (reservas[j]->getCodigo() == actual->getCodigo()) //PROBLEMA AQUÍ DE DEBUG
                reservas[j] = actual;
        }
    }
}

Huesped::~Huesped() {
    delete[] reservas;
}
#include "controlador.h"

int main() {
    Controlador app;
    app.iniciar();

    return 0;
}

#include "reserva.h"
#include "alojamiento.h"
#include "huesped.h"
#include <iostream>
#include <cstring>

// Constructor por defecto
Reserva::Reserva()
    : codigo(""), alojamiento(nullptr), huesped(nullptr),
    fechaEntrada(), duracion(0), metodoPago(""),
    fechaPago(), monto(0)
{
    anotacion[0] = '\0';
}

// Constructor parametrizado
Reserva::Reserva(const std::string& cod, Alojamiento* alo, Huesped* h,
                 const Fecha& entrada, int dur, const std::string& metodo,
                 const Fecha& pago, int m, const std::string& nota)
    : codigo(cod), alojamiento(alo), huesped(h),
    fechaEntrada(entrada), duracion(dur), metodoPago(metodo),
    fechaPago(pago), monto(m)
{
    std::strncpy(anotacion, nota.c_str(), 1000);
    anotacion[1000] = '\0'; // Seguridad: null-terminar
}

// Constructor de copia
Reserva::Reserva(const Reserva& otra)
    : codigo(otra.codigo), alojamiento(otra.alojamiento),
    huesped(otra.huesped), fechaEntrada(otra.fechaEntrada),
    duracion(otra.duracion), metodoPago(otra.metodoPago),
    fechaPago(otra.fechaPago), monto(otra.monto)
{
    std::strcpy(anotacion, otra.anotacion);
}

// Operador de asignación
Reserva& Reserva::operator=(const Reserva& otra) {
    if (this != &otra) {
        codigo = otra.codigo;
        alojamiento = otra.alojamiento;
        huesped = otra.huesped;
        fechaEntrada = otra.fechaEntrada;
        duracion = otra.duracion;
        metodoPago = otra.metodoPago;
        fechaPago = otra.fechaPago;
        monto = otra.monto;
        std::strcpy(anotacion, otra.anotacion);
    }
    return *this;
}

// Getters
std::string Reserva::getCodigo() const { return codigo; }
Alojamiento* Reserva::getAlojamiento() const { return alojamiento; }
Huesped* Reserva::getHuesped() const { return huesped; }
Fecha Reserva::getFechaEntrada() const { return fechaEntrada; }
int Reserva::getDuracion() const { return duracion; }
std::string Reserva::getMetodoPago() const { return metodoPago; }
Fecha Reserva::getFechaPago() const { return fechaPago; }
int Reserva::getMonto() const { return monto; }
std::string Reserva::getAnotacion() const { return std::string(anotacion); }

// Mostrar comprobante
void Reserva::mostrarComprobante() const {
    Fecha salida = fechaEntrada.sumarDias(duracion);
    Fecha hoySistema = getFechaSistema();

    std::cout << "------------------------------\n";
    std::cout << "=== COMPROBANTE DE RESERVA ===\n";
    std::cout << "Reserva: " << codigo << '\n';
    std::cout << "Nombre del huésped: " << (huesped ? huesped->getNombre() : "N/A") << '\n';
    std::cout << "Alojamiento: " << (alojamiento ? alojamiento->getCodigo() : "N/A") << '\n';
    std::cout << "Duración: " << duracion << " noche(s)\n";
    std::cout << "Entrada: "; fechaEntrada.mostrarExtendido();
    std::cout << "Salida: "; salida.mostrarExtendido();
    std::cout << "Método de pago: " << metodoPago << '\n';
    std::cout << "Pago realizado el: "; hoySistema.mostrarExtendido();
    std::cout << "Monto: $" << monto << '\n';
    std::cout << "Anotación: " << anotacion << '\n';
    std::cout << "------------------------------\n";
}

// Verifica coincidencia de reserva
bool Reserva::coincideCon(const Fecha& entrada, int dur) const {
    return fechaEntrada.toEntero() == entrada.toEntero() && duracion == dur;
}
